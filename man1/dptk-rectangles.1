.\" Automatically generated by Pandoc 2.7.3
.\"
.TH "VIS-RECTANGLES.PY" "1" "March 03, 2021" "1.2.0" "Dispersion Toolkit Manuals"
.hy
.SH NAME
.PP
vis-rectangles.py - visualise a sequence of a set of rectangles
.SH SYNOPSIS
.PP
\f[B]vis-rectangles.py\f[R] [\f[B]--i\f[R] \f[I]FILE\f[R]]
[\f[B]--pts\f[R] \f[I]FILE\f[R]] [\f[B]--domain\f[R]=\f[I]QUARTUPLE OF
BINARY64\f[R]] [\f[B]--gridlines\f[R]=\f[I]PAIR OF INTEGER\f[R]]
[\f[B]--delay\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--image-path\f[R]=\f[I]PATTERN\f[R]]
[\f[B]--image-ppi\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--colour-alpha-edge\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--colour-rgba-edge\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]]
[\f[B]--colour-edge\f[R]=\f[I]STRING\f[R]]
[\f[B]--colour-alpha-fill\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--colour-rgba-fill\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]]
[\f[B]--colour-fill\f[R]=\f[I]STRING\f[R]]
[\f[B]--fill\f[R]=\f[I]INTEGER\f[R]]
[\f[B]--colour-alpha-pts\f[R]=\f[I]BINARY64\f[R]]
[\f[B]--colour-rgba-pts\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]]
[\f[B]--colour-pts\f[R]=\f[I]STRING\f[R]] [\f[B]--silent\f[R]]
.SH DESCRIPTION
.PP
Visualises a sequence of a set of rectangles, and how they change within
this sequence.
.SH OPTIONS
.TP
.B \f[B]--i\f[R]=\f[I]FILE\f[R], \f[B]--i\f[R] \f[I]FILE\f[R]
Retrieves a sequence of a set of rectangles from \f[I]FILE\f[R], each as
a 4 dimensional point set, whereas a point
.RS
.PP
(coord_min_d0 coord_min_d1 coord_max_d0 coord_max_d1)
.PP
corresponds to a rectangle with its smallest and greatest coordinates
coord_min_d\f[I]d\f[R] and coord_max_d\f[I]d\f[R] along dimension
\f[I]d\f[R], respectively.
.PP
The absence of \f[I]FILE\f[R] is substituted by \f[I]stdin\f[R].
The end of a point set, which equals the line #eos, updates the figure.
.RE
.TP
.B \f[B]--pts\f[R]=\f[I]FILE\f[R]
Retrieves a 2 dimensional point set sequence from \f[I]FILE\f[R].
It is assumed that its sequence length equals the sequence length of the
set of rectangles.
.TP
.B \f[B]--domain\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]
The problem domain in d=2 dimensions, formatted as [min d=0, min d=1,
max d=0, max d=1] and with min d < max d.\ Default: [0,0,1,1].
.TP
.B \f[B]--gridlines\f[R]=\f[I]PAIR OF INTEGER\f[R]
The number of gridlines within the d=2 dimensional problem domain,
including the domain boundary itself, formatted as [num d=0, num d=1]
with each number being non-negative.
Default: [7,7].
.TP
.B \f[B]--delay\f[R]=\f[I]BINARY64\f[R]
The animation speed is slowed down by introducing a delay of
\f[I]BINARY64\f[R] seconds between frame updates.
A frame update corresponds to the end of point set within the sequence.
.TP
.B \f[B]--image-path\f[R]=\f[I]PATTERN\f[R]
Each frame may be stored to a file as a realisation of formatting
\f[I]PATTERN\f[R].
This \f[I]PATTERN\f[R] is required to contain \f[I]{i}\f[R] to be
substituted by the current point set index within the sequence.
For instance,
.RS
.PP
python vis-rectangles.py --image-path=\[lq]./seq-{i}.png\[rq]
.PP
reads the rectangles from \f[I]stdin\f[R] and stores the resulting
figures to
.PP
\&./seq-0.png ./seq-1.png \&... ./seq-n.png
.PP
for n+1 sets of rectangles given.
.RE
.TP
.B \f[B]--image-ppi\f[R]=\f[I]BINARY64\f[R]
The resolution of the resulting images, pixel per inch (PPI) unit.
Default value: 300.
.TP
.B \f[B]--colour-alpha-edge\f[R]=\f[I]BINARY64\f[R]
Set the alpha channel of the RGBA colour of rectangle edges to be
\f[I]BINARY64\f[R], with 0 <= \f[I]BINARY64\f[R] <= 1.
.TP
.B \f[B]--colour-rgba-edge\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]
Set the RGBA colour of rectangle edges to be
.RS
.PP
\f[I]QUARTUPLE OF BINARY64\f[R] = \f[I]BINARY64\f[R] \f[I]BINARY64\f[R]
\f[I]BINARY64\f[R] \f[I]BINARY64\f[R]
.PP
with 0 <= \f[I]BINARY64\f[R] <= 1.
.RE
.TP
.B \f[B]--colour-edge\f[R]=\f[I]STRING\f[R]
Set the RGBA colour of rectangle edges interpreted from the literal
\f[I]STRING\f[R] using matplotlib.colors.to_rgba(\f[I]STRING\f[R]).
See also https://matplotlib.org/stable/tutorials/colors/colors.html.
.TP
.B \f[B]--colour-alpha-fill\f[R]=\f[I]BINARY64\f[R]
Set the alpha channel of the RGBA colour of rectangle interiours to be
\f[I]BINARY64\f[R], with 0 <= \f[I]BINARY64\f[R] <= 1.
.TP
.B \f[B]--colour-rgba-fill\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]
Set the RGBA colour of rectangle interiours to be
.RS
.PP
\f[I]QUARTUPLE OF BINARY64\f[R] = \f[I]BINARY64\f[R] \f[I]BINARY64\f[R]
\f[I]BINARY64\f[R] \f[I]BINARY64\f[R]
.PP
with 0 <= \f[I]BINARY64\f[R] <= 1.
.RE
.TP
.B \f[B]--colour-fill\f[R]=\f[I]STRING\f[R]
Set the RGBA colour of rectangle interiours interpreted from the literal
\f[I]STRING\f[R] using matplotlib.colors.to_rgba(\f[I]STRING\f[R]).
See also https://matplotlib.org/stable/tutorials/colors/colors.html.
.TP
.B \f[B]--fill\f[R]=\f[I]INTEGER\f[R]
Rectangles are filled with a colour as long as \f[I]INTEGER\f[R] != 0.
If set to zero, specifying \f[B]--colour-alpha-fill\f[R],
\f[B]--colour-rgba-fill\f[R] and/or \f[B]--colour-fill\f[R] will not
have any effect.
.TP
.B \f[B]--colour-alpha-pts\f[R]=\f[I]BINARY64\f[R]
Set the alpha channel of the RGBA colour of points specified with
\f[B]--pts\f[R] to be \f[I]BINARY64\f[R], with 0 <= \f[I]BINARY64\f[R]
<= 1.
.TP
.B \f[B]--colour-rgba-pts\f[R]=\f[I]QUARTUPLE OF BINARY64\f[R]
Set the RGBA colour of points specified with \f[B]--pts\f[R] to be
.RS
.PP
\f[I]QUARTUPLE OF BINARY64\f[R] = \f[I]BINARY64\f[R] \f[I]BINARY64\f[R]
\f[I]BINARY64\f[R] \f[I]BINARY64\f[R]
.PP
with 0 <= \f[I]BINARY64\f[R] <= 1.
.RE
.TP
.B \f[B]--colour-pts\f[R]=\f[I]STRING\f[R]
Set the RGBA colour of points specified with \f[B]--pts\f[R] interpreted
from the literal \f[I]STRING\f[R] using
matplotlib.colors.to_rgba(\f[I]STRING\f[R]).
See also https://matplotlib.org/stable/tutorials/colors/colors.html.
.TP
.B \f[B]--silent\f[R]
Suppress comments in the output stream, yielding only the computed
value.
The latter could be the point set or its cardinality.
.SH DYNAMIC DEPENDENCIES
.IP \[bu] 2
python3
.IP \[bu] 2
numpy
.IP \[bu] 2
matplotlib
.SH LIMITATION
.PP
The algorithm requires a two-dimensional point set sequence.
.SH AUTHORS
Benjamin Sommer.
