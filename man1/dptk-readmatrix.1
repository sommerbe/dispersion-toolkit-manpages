.\"t
.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "READ-MATRIX" "1" "April 23, 2021" "1.3.0" "Dispersion Toolkit Manuals"
.hy
.SH NAME
.PP
read-matrix - reads a matrix of points
.SH SYNOPSIS
.PP
\f[B]read-matrix\f[R] [\f[B]--i\f[R] \f[I]FILE\f[R]] [\f[B]--o\f[R]
\f[I]FILE\f[R]]
\f[B]--domain-boundary\f[R]=\f[I]LIST_OF_NUMBERS\f[R]|\f[B]--domain-boundary-unity\f[R]
[\f[B]--mathematica\f[R]] [\f[B]--csv\f[R]]
[\f[B]--point-delimiter\f[R]=\f[I]CHARACTER\f[R]]
[\f[B]--coord-delimiter\f[R]=\f[I]CHARACTER\f[R]]
[\f[B]--point-prefix\f[R]=\f[I]CHARACTER\f[R]]
[\f[B]--point-suffix\f[R]=\f[I]CHARACTER\f[R]]
[\f[B]--set-prefix\f[R]=\f[I]CHARACTER\f[R]]
[\f[B]--set-suffix\f[R]=\f[I]CHARACTER\f[R]]
[\f[B]--delimiter\f[R]=\f[I]CHARACTER\f[R]] [\f[B]--silent\f[R]]
.SH DESCRIPTION
.PP
Reads a matrix of points, where each column corresponds to a distinct
dimension, and where each row represents a point.
.SH OPTIONS
.TP
\f[B]--i\f[R] \f[I]FILE\f[R], \f[B]--i\f[R]=\f[I]FILE\f[R]
Retrieves a point set from \f[I]FILE\f[R].
Its absence is substituted by \f[I]stdin\f[R].
.TP
\f[B]--o\f[R] \f[I]FILE\f[R], \f[B]--o\f[R]=\f[I]FILE\f[R]
Redirects the point set sequence to \f[I]FILE\f[R], opened in overwrite
mode (not appending mode).
Without \f[I]FILE\f[R], results are forwarded to \f[I]stdout\f[R].
Errors encountered during the program\[cq]s execution are streamed into
\f[I]stderr\f[R], and not into either \f[I]stdout\f[R] or
\f[I]FILE\f[R].
.TP
\f[B]--delimiter\f[R]=\f[I]CHARACTER\f[R]
A point set\[cq]s coordinates are separated by \f[I]CHARACTER\f[R],
while each point resides on a distinct line.
Recommended condition: \f[I]CHARACTER\f[R] = \[aq] \[aq],
\f[I]CHARACTER\f[R] = \[aq]\[rs]t\[aq].
.TP
\f[B]--domain-boundary\f[R]=\f[I]LIST_OF_NUMBERS\f[R]
A list of non-quoted numbers
.RS
.PP
n1 n2 \&... nk
.PP
with k = 2 * dimension of point set, and which is ordered such that the
first k/2 numbers correspond to the lower bound of the problem domain,
and the remaining numbers to its upper bound.
In addition, these numbers are ordered with increasing dimension index.
.RE
.TP
\f[B]--domain-boundary-unity\f[R]
Defines the domain-boundary to be [0,1]\[ha]d, in d dimensions.
.TP
\f[B]--mathematica\f[R]
The matrix format of Mathematica.
Here:
.RS
.PP
{{P0C0,P0C1,\&...,P0Ck},{P1C0,P1C1,\&...,P1Ck},\&...,{PnC0,PnC1,\&...,PnCk}}
.PP
is a matrix of \f[I]n\f[R] points, each having \f[I]k\f[R] coordinates.
.RE
.TP
\f[B]--csv\f[R]
A simple text based format following
.RS
.PP
.TS
tab(@);
l l l l.
T{
P0C0
T}@T{
P0C1
T}@T{
\&...
T}@T{
P0Ck
T}
T{
P1C0
T}@T{
P1C1
T}@T{
\&...
T}@T{
P1Ck
T}
T{
\&.
T}@T{
\&.
T}@T{
\&.
T}@T{
\&.
T}
T{
\&.
T}@T{
\&.
T}@T{
\&.
T}@T{
\&.
T}
T{
\&.
T}@T{
\&.
T}@T{
\&.
T}@T{
\&.
T}
T{
PnC0
T}@T{
PnC1
T}@T{
\&...
T}@T{
PnCk
T}
.TE
.PP
is a matrix of \f[I]n\f[R] points, each having \f[I]k\f[R] coordinates.
Colomns are separated by a single empty space ( ).
There is no line before the first row, and there is not line after the
last row.
Each point is written on a distinct row, terminated with EOL character
(\[rs]n).
.RE
.TP
\f[B]--point-delimiter\f[R]=\f[I]CHARACTER\f[R]
The character to \f[I]seperate two points\f[R].
In the Mathematica format, this would be
.RS
.PP
{{P0C0,P0C1,\&...,P0Ck}\f[I]CHARACTER\f[R]{P1C0,P1C1,\&...,P1Ck}\f[I]CHARACTER\f[R]\&...\f[I]CHARACTER\f[R]{PnC0,PnC1,\&...,PnCk}}.
.RE
.TP
\f[B]--coord-delimiter\f[R]=\f[I]CHARACTER\f[R]
The character to \f[I]seperate two coordinates\f[R].
In the Mathematica format, this would be
.RS
.PP
{{P0C0\f[I]CHARACTER\f[R]P0C1\f[I]CHARACTER\f[R]\&...\f[I]CHARACTER\f[R]P0Ck}}.
.RE
.TP
\f[B]--point-prefix\f[R]=\f[I]CHARACTER\f[R]
The character to \f[I]prefix a point\f[R] (to the left).
In the Mathematica format, this would be
.RS
.PP
{\f[I]CHARACTER\f[R]P0C0,P0C1,\&...,P0Ck}}.
.RE
.TP
\f[B]--point-suffix\f[R]=\f[I]CHARACTER\f[R]
The character to \f[I]postfix a point\f[R] (to the right).
In the Mathematica format, this would be
.RS
.PP
{{P0C0,P0C1,\&...,P0Ck\f[I]CHARACTER\f[R]}.
.RE
.TP
\f[B]--set-prefix\f[R]=\f[I]CHARACTER\f[R]
The character to \f[I]prefix a point set\f[R] (to the left).
In the Mathematica format, this would be
.RS
.PP
\f[I]CHARACTER\f[R]{P0C0,P0C1,\&...,P0Ck}}.
.RE
.TP
\f[B]--set-suffix\f[R]=\f[I]CHARACTER\f[R]
The character to \f[I]postfix a point set\f[R] (to the right).
In the Mathematica format, this would be
.RS
.PP
{{P0C0,P0C1,\&...,P0Ck}\f[I]CHARACTER\f[R].
.RE
.TP
\f[B]--silent\f[R]
Suppress comments in the output stream, yielding only the computed
value.
The latter could be the point set or its cardinality.
.SH EXAMPLES
.PP
Read a standard CSV file where each coordinates are separated by a hard
whitespace (\[cq] \[cq]), and where each point is on a distinct line,
from a d=3 dimensional point set, bounded by [0,1]\[ha]3:
.IP
.nf
\f[C]
read-matrix --i Frolov_3_3_basic.dat --csv --domain-boundary 0 0 0 1 1 1
\f[R]
.fi
.PP
Read matrices exported from Mathematica, from a d=2 dimensional point
set, bounded by [0,1]x[0,1]:
.IP
.nf
\f[C]
read-matrix --i matrix-mathematica.csv --mathematica --domain-boundary 0 0 1 1
\f[R]
.fi
.SH LIMITATION
.PP
The algorithm requires a point set, not a point set sequence.
.SH AUTHORS
Benjamin Sommer.
